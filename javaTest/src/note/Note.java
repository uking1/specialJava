//학생코드 3237

// &&and 앞이 거짓이면 뒤를 실행 안함 || or 는 앞이 트루면 뒤를 실행안함

//랜덤 난수 구하는법 
//Math.Random()*(최대+최소+1)+최소);

//===다형성===
//1.상속 한다
//2.메소드 오버라이딩 발생=>접근제어자가 같거나 커야한다, 리턴값 같아야한다,
//  매개변수 타입 갯수 같아야한다, 
//  예외처리가 커야한다.부모함수,자식함수 완벽하게 동일할때
//3.부모 객체참조변수로 부모함수를 부르면 부모의 함수가아닌 오버라이딩된
//  자식함수를 실현
//4. 부모 객체참조변수는 자식의 함수를 받을수있다.
//5. 자식 객체참조변수는 부모하의 함수를 받을수도있고 못받을수도있다.
// ㄴ (자식것이 부모에게있으면 받고 없으면 못받음)


//오버로딩(오버라이딩의 1,2번은 필요없음) => 상속시 상속안할때 둘다발생할수있음
//1.함수명이 같아야함
//2.매개변수 갯수가 틀려야함
//3.매개변수 갯수가 같을경우 타입이 틀려야함

//오버라이딩 => 상속시 발생
//1. 접근제어자 같아야함 (같거나 커야함)
//2. 리턴값 같아야함
//3. 함수명 같아야함
//4. 매개변수 갯수,타입 같아야함
//5. 예외처리도 같아야함 (같거나 작아야함)

//동적바인딩
//다형성일때 발생이 되고, 자식이 부모를 상속을 받았을때 오버라이딩을 하게 되면 
//부모객체참조변수를 부를때 부모의 함수가 불러지는게 아니라 오버리이딩된 자식의 함수가 불려지는것을 동적바인딩

//정적바인딩
//컴파일할때 어떤 함수를 부르면 미리 그 함수를 결정이되는것이 정적바인딩


//클래스 멤버변수 는 클래스로부터 만들어진 모든 객체들이 공동으로 사용하기위한 변수
//클래스 멤버변수 는 메모리에서 로딩될때 만들어짐 -> 메소드 영역에 값을 안주면 디폴드 값으로 자동설정
//인스턴트 멤버변수는 (객체)는 new 하는순간 만들어짐
//클래스 변수는 모든 객체가 공유할수있다

//모호성 => 하나의 자식이 여러 부모를 상속받을때(다중상속) 그속에 있는 멤버변수, 함수가 똑같은 멤버변수, 함수가 있을때 어떤 부모거인지는 모른다  

// ==상속== extends
//부모 클래스 -> 수퍼클래스 / 자식 클래스 -> 서브클래스  ==> this영역에 있음
//상속을 받을땐 단일 상속이 된다.(모호성 때문에 중복이 안됨) 모호성을 없애면 다중상속이 가능하다=>"인터페이스"를 이용해 체계화시키는게 가능
//부모객체가 만들어지고 내 객체가 만들어진다. 상속을 받으면 부모것은 내것이됨
//부모객체는 내 번지 안에 있으며 부모번지는 없다.(번지가 두개가 있을수는 없음)
//두 번지 안에 영역에는 부모의 영역도 있고, 나만의 영역도 있음

//===추상메소드== abstract
//멤버함수인데 구현부가 없는 메소드,팥없는 붕어빵
//상속받은 클래스에서 추상메소드(abstract)가 있으면 무조건 오버라이딩해서 구현해야함
//추상메소드가 하나라도 있으면 추상클래스
//일반 클래스와 똑같으나 추상메소드만 있다//추상클래스는 혼자 객체를만들수없음
//무조건 오버라이딩 하게하려고 쓰임.

//===인터페이스===
//상수와 추상메소드만 존재함
//생성자가 없다 , 객체가 안만들어진다
//인터페이스끼리는 상속, 다중상속가능 extends 사용 

//박싱과 언박싱
//박싱 기본타입을 Wrapper 타입으로 변환
//언박싱 Wrapper타입에 있는 기본타입을 빼내는것

//Calendar 객체 생성 
// Calendar now = Calendar.getInstance();


//////////////////////로컬 레파짓토리(1~23)//////////////////////
//=====1.형상관리(버전관리)=====
//한 프로젝트를 함에 있어서 프로젝트의 과정중의 삭제,추가,삽입등 관리해주고 추적할수 있도록 해주는 프로그램

//=====2.git=====
//로컬 레파짓토리 환경안에서 버전관리를 해줄수 있게하는 프로그램

//=====3.github=====
//로컬 레파짓토리를 모든 팀원들이 공유할수있도록 리모트레파짓토리를 관리해주는 프로그램

//=====4.sourceTree=====
//명령어로만 사용했던 깃을 버튼,그래프,메뉴등으로 더 편리하게 이용하게 만들어주는 프로그램

//=====5.git bash=====
//로컬 레파짓토리 환경을 커맨드 환경에서 작업할수있게 해주는 프로그램

//=====6.pull=====
//리모트레파짓토리를 로컬 레파짓토리로 오는것

//=====7.push=====
//로컬레파짓토리에서 리모트레파짓토리로 오는것

//=====8.git init=====
//로컬레파짓토리 저장소를 만들때 초기화 시키는것

//=====9.stage=====
//버전관리를 하는데에 있어서 여러 파일을 동시에 하나의 버전관리로 진행할수있게 하는것

//=====10.working directory=====
//작업하고 있는 폴더

//=====11.add=====
//버전관리하고 싶을때 스테이지에 한개 파일을 할땐 add 모두할땐 add all

//=====12.commit=====
//스테이지에 있는 파일을 로컬레파지토리(저장소)에 버전관리로 등록하는것

//=====13.untracted, traced=====
//언트랙트 - 버전관리 시스템에서 버전관리가 안되는파일 , 트랙트- 버전관리가 되어있는 파일

//=====14.local repository, remote repository=====
//로컬레파짓토리 - 지역저장소에서 버전관리를 저장하는 장소, 리모트레파짓토리 -모든 사람이 공유하는저장소에서 버전관리하는 장소

//=====15.git ignore===== gitignore.io 사이트 이용
//버전관리 대상에서 제외하고 싶은 무시할 파일이나 폴더 목록을 적은 파일

//=====16.tag=====
//특정 커밋에 붙일수있는 꼬리표(커밋이 여러개 있는 상황에서 어떤 의미의 커밋을 가지고있는지 한눈에 알수있음)

//=====17.버전비교하기=====
//두 커밋사이에 자료변화를 확인가능

//=====18.되돌리기=====
//(스테이지 되돌리기) (작업디렉토리: 폐기(추적된사항 원래대로), 제거(파일을 아예 제거)
//커밋 : reset,revert //리셋은 과거로 돌아가면서 커밋 유지가 안됨, 리버트는 커밋이 유지가됨 

//=====19. reset: Hard, mixed, soft=====
//과거로 돌아가면서 커밋이 유지가안됨
// 하드 -> 아예삭제 믹스->스테이지 전(작업디렉토리)까지 소프트->스테이지까지 올려놓음

//=====20. revert=====
//커밋의 변경사항을 되돌리는것(커밋이 유지됨)
//과거로 돌아가는시점까지 차례대로 revert할것

//=====21. stash=====
//임시저장하는 기능

//=====22.branch, merge, 충돌해결(소스트리하지말고,개발툴에서 진행하는게 좋음)====
//브랜치 -> 버전을 여러흐름으로 나눠 관리하는거 merge->합병

//=====23.rebase=====
//재배치.충돌해결

//==================================================================== 

//=====24.clone=====


//=====25.push=====


//=====26.tetch=====


//=====27.pull=====


//=====28.ssh통신 인증방법(비밀키,공개키)=====

//풀리퀘스트
//팀장이 리모트레파짓토리를 만들고 팀원이 포크를 한 뒤 본인 깃허브에 복제를한다 
//그 후에 클론을 하고 브랜치를 해서 작업을 병합은 하지 않고 포크한곳으로 푸쉬 하고
//팀장한테 풀리퀘스트를 요청하고 팀장이 병합한다 그리고 팀장이 가지고있는 리모트레파지토리에 팀원들이 풀땡겨서 같게만든다
//그리고 본인이 포크한곳은 다르니 푸쉬를한다.

//서버 www : 80 , ftp:21 , telnet :23 , dns :53, smtp :25

//컬렉션
//멤버함수와의 차이 -> 크기의 제한이 없다. 컬렉션은 삽입,삭제의 불편함이없다
//컬렉션은 멤버함수가 정의되어있다
//Stack , Set , List , Queue , Map
package note;

